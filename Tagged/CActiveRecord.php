<?php
namespace Yiix\Cache\Tagged;

/**
 *
 * @author magic
 */
class CActiveRecord extends \CActiveRecord
{

    /**
     * number of seconds for cached data
     *
     * @var integer
     */
    const CACHE_DURATION = 3600;

    /**
     * the number of queries that can be cached by current cache settings
     *
     * @var integer
     */
    const CACHE_QUERY_COUNT = PHP_INT_MAX;

    /**
     * define rules for generating tags. each model should declare this method to get it working
     *
     * should return value based on mode.
     *
     * 'write' mode:
     *
     * will use tags for renewing tags. once object saved than tags from write mode will be cleared and all depended object will renew their caches. so be carefull, for example if tag user_xxx will be removed than almost all cache will be renewed.
     *
     * usually at write mode needs to be set only model related tags, like 'id' or other table columns.
     *
     * 'read' mode:
     *
     * mode 'read' will use tags for reading.
     * under this mode we can set any column id. reading mode is safe, cause no tags deletion happening
     *
     *
     * return data:
     *
     * is array. item selects by various of types, like 'tagname', 'tagscomposition', 'tagalias'.
     *
     *  1.  tagname item,
     *      detects by item key, if key is numeric and value is string, than system decides it as 'tagname' and will be used directly
     *      example:
     *          class MWebsite{
     *              public function cacheTags($mode='read'){
     *                  return array('id','site_id','customer_id')
     *              }
     *          }
     *
     *  2.  tags composition item.
     *      if item value is array than it is 'tags composition'. which means system will generate tag based on few tagnames
     *      example:
     *          class MWebsite{
     *              public function cacheTags($mode='read'){
     *                  return array(
     *                      'id','site_id','customer_id',
     *                      array(
     *                          'customer_id',
     *                          'domain'
     *                      )
     *                  )
     *              }
     *          }
     *
     *  3. tag alias
     *      if tag key and value are string than it is tag alias. tag aliases needed because table can use different column names. so to make tags use single name we should use aliases.
     *      for example customer_id - is tag which linking to MUser model, so it is good to add alias for it.
     *      example:
     *          class MWebsite{
     *              public function cacheTags($mode='read'){
     *                  return array(
     *                      'customer_id'=>'user_id'
     *                  )
     *              }
     *          }
     *
     *  4. unprefixed tag
     *      if tag name first character is ':' than it will not be prefixed by model class name
     *      example:
     *          class MWebsite{
     *              public function cacheTags($mode='read'){
     *                  return array(
     *                      ':website_id',
     *                      ':site_id',
     *                      'customer_id'=>':user_id'
     *                  )
     *              }
     *          }
     *
     *
     * @param string $mode
     * @return array
     */
    public function cacheTags($mode='read')
    {
        switch ($mode) {
        	case 'write':
        	    return array();
        	    break;
            case 'read':
                return array();
                default:
            break;
        }
    }

    /**
     * generate tags based on given attributes
     * tags will be generated by rules took from @cacheTags method
     *
     * @param array|CDbCriteria $attributes
     * @return array
     */
    protected function generateTags($attributes=array(),$mode='read')
    {
        $tags = Helper::generateTags($this,$attributes,$mode);
        $tags = Helper::mergeTags($tags,Helper::generateTags($this,$this->getDbCriteria()));
        return $tags;
    }

    /**
     * generate tags by using primary key generator helper
     *
     * @param mixed $pk
     * @param string $mode
     * @return array
     */
    protected function generatePrimaryKeyTags($pk, $mode='read')
    {
        $attributes = Helper::generatePrimaryKeyTagValues($this, $pk);
        return $this->generateTags($attributes,$mode);
    }

    /**
     * overide CActiveRecord method, added cahing functionality
     *
     * @param mixed $pk
     * @param mixed $condition
     * @param array $params
     */
    public function findByPk($pk,$condition='',$params=array()){

        $tags = $this->generatePrimaryKeyTags($pk);
        if (!empty($tags)) {
            $this->cache(self::CACHE_DURATION, new Dependency($tags),self::CACHE_QUERY_COUNT);
        }

        return parent::findByPk($pk,$condition='',$params=array());
    }

    /**
     * generate cache tags
     *
     * @see CActiveRecord::findAllByPk()
     */
    public function findAllByPk($pk,$condition='',$params=array()){

        $tags = $this->generatePrimaryKeyTags($pk);

        if (!empty($tags)) {
            $this->cache(self::CACHE_DURATION, new Dependency($tags),self::CACHE_QUERY_COUNT);
        }

        return parent::findAllByPk($pk,$condition='',$params=array());
    }

    /**
     * generate cache tags
     *
     * @see CActiveRecord::find()
     */
    public function find($condition='',$params=array()){
        $criteria=$this->getCommandBuilder()->createCriteria($condition,$params);

        $tags = $this->generateTags($criteria);
        if (!empty($tags)) {
            $this->cache(self::CACHE_DURATION, new Dependency($tags),self::CACHE_QUERY_COUNT);
        }

        return $this->query($criteria);
    }

    /**
     * generate cache tags
     *
     * @see CActiveRecord::findAll()
     */
    public function findAll($condition='',$params=array()) {

        $criteria=$this->getCommandBuilder()->createCriteria($condition,$params);

        $tags = $this->generateTags($criteria);
        if (!empty($tags)) {
            $this->cache(self::CACHE_DURATION, new Dependency($tags),self::CACHE_QUERY_COUNT);
        }

        return $this->query($criteria,true);
    }

    public function findAllByAttributes($attributes,$condition='',$params=array()) {
        $tags = $this->generateTags($attributes);

        if (!empty($tags)) {
            $this->cache(self::CACHE_DURATION, new Dependency($tags),self::CACHE_QUERY_COUNT);
        }

        return parent::findAllByAttributes($attributes,$condition,$params);
    }

    /**
     * generate cache tags
     *
     * @see CActiveRecord::findByAttributes()
     */
    public function findByAttributes($attributes,$condition='',$params=array()) {

        $tags = $this->generateTags($attributes);

        $d = new Dependency($tags);

        if (!empty($tags)) {
            $this->cache(self::CACHE_DURATION, $d,self::CACHE_QUERY_COUNT);
        }
        return parent::findByAttributes($attributes, $condition, $params);
    }

    /**
     * generate cache tags
     *
     * @see CActiveRecord::afterSave()
     */
    protected function afterSave()
    {
        $tags = Helper::generateTags($this,$this->attributes,'write');
        if (!empty($tags)) {
            Helper::deleteByTags($tags);
        }

        parent::afterSave();
    }

    /**
     * delete bound tags
     *
     * @see CActiveRecord::afterDelete()
     */
    protected function afterDelete()
    {
        $tags = Helper::generateTags($this,$this->attributes,'write');
        if (!empty($tags)) {
            Helper::deleteByTags($tags);
        }

        parent::afterDelete();
    }

    /**
     * generate cache tags
     *
     * @see CActiveRecord::getRelated()
     */
    public function getRelated($name,$refresh=false,$params=array())
    {
        $md = $this->getMetaData();
        $tags = array();

        if(isset($md->relations[$name])) {

            $relation = $md->relations[$name];

            $model = call_user_func(array($relation->className,'model'));
            if ($relation instanceof \CHasManyRelation) {

                if (is_array($relation->foreignKey)) {
                    $tagValues = array();
                    foreach ($relation->foreignKey as $fk => $pk) {
                        $tagValues[$fk] = $this->$pk;
                    }
                } else {
                    $tagValues = array(
                        $relation->foreignKey=>$this->getPrimaryKey()
                    );
                }
            } elseif ($relation instanceof \CHasOneRelation) {
                if (is_array($relation->foreignKey)) {
                    $tagValues = array();
                    foreach ($relation->foreignKey as $fk => $pk) {
                        $tagValues[$fk] = $this->$pk;
                    }
                } else {
                    $tagValues = array(
                        $relation->foreignKey=>$this->getPrimaryKey()
                    );
                }
            } elseif ($relation instanceof \CBelongsToRelation) {

                if (is_array($relation->foreignKey)) {
                    $tagValues = array();
                    foreach ($relation->foreignKey as $fk => $pk) {
                        $tagValues[$pk] = $this->$fk;
                    }
                } else {
                    $tagValues = array(
                        $this->getTableSchema()->primaryKey => $this->{$relation->foreignKey}
                    );
                }
            }

            if (!empty($tagValues)) {
                $tags = $model->generateTags($tagValues);
            }

            if($params instanceof CDbCriteria) {
                $tags = Helper::mergeTags($tags,$model->generateTags($params));
            }
        }
        if (!empty($tags)) {
            $this->cache(self::CACHE_DURATION, new Dependency($tags),self::CACHE_QUERY_COUNT);
        }

        return parent::getRelated($name,$refresh,$params);
    }
}